package main

import (
	"crypto/md5"
	"database/sql"
	"fmt"
	"io/ioutil"
	"log"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/jedib0t/go-pretty/table"
	_ "github.com/sijms/go-ora/v2" // Import the Oracle driver package
)

var folderPath string
var db *sql.DB

func oracle(host, port, database, username, password, folderPath, action, prestatefile, walletLocation, service, prescript, postscript, difference, tag string, logger *log.Logger) {
	switch action {
	case "migrate":
		processOracle(username, password, host, port, service, walletLocation, folderPath, tag, logger)
	case "clear":
		oracledelete(username, password, host, port, service, walletLocation, logger)
	case "clearall":
		oracledelete_all(username, password, host, port, service, walletLocation, logger)
	case "check":
		oracleCheckScripts(username, password, host, port, service, walletLocation, folderPath, logger)
	case "snapshot":
		oracleGenerateMigrationScript(host, port, database, username, password, folderPath, walletLocation, service, prestatefile, logger)
	case "delta":
		oracle_processFiles(folderPath, prescript, postscript, difference)
	default:
		logger.Println("Unsupported action:", action)
	}
}

func processOracle(username, password, host, port, service, walletLocation, folderPath, tag string, logger *log.Logger) *sql.DB {
	connectionString := "oracle://" + username + ":" + password + "@" + host + ":" + port + "/" + service
	if walletLocation != "" {
		connectionString += "?TRACE FILE=trace.log&SSL=enable&SSL Verify=false&WALLET=" + url.QueryEscape(walletLocation)
	}

	db, err := sql.Open("oracle", connectionString)
	if err != nil {
		logger.Printf("Error opening database connection: %v", err)
		return nil
	}

	err = db.Ping()
	if err != nil {
		logger.Printf("Error pinging database: %v", err)
		return nil
	}

	createTableQuery := `
	BEGIN
		EXECUTE IMMEDIATE 'CREATE TABLE tbl_version (
			ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
			Major VARCHAR2(10),
			Minor VARCHAR2(10),
			Change VARCHAR2(10),
			Status VARCHAR2(10),
			HashCode VARCHAR2(32),
			ExecutionTime TIMESTAMP
		)';
	EXCEPTION
		WHEN OTHERS THEN
			IF SQLCODE != -955 THEN
				RAISE;
			END IF;
	END;
	`
	_, err = db.Exec(createTableQuery)
	if err != nil {
		logger.Fatalf("Error creating table: %v", err)
	}

	var scriptIDCounter int
	hashCodes := retrieveHashCodesOracle(db)
	fmt.Println("Connected to Oracle database")

	var skippedFiles []string
	tableWriter := table.NewWriter()
	tableWriter.SetOutputMirror(logger.Writer())
	tableWriter.AppendHeader(table.Row{"Id", "Major", "Minor", "Change", "Status", "Hash Code", "Execution Time"})
	scriptIDCounter = 0

	err = filepath.Walk(folderPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			logger.Printf("Error accessing file %s: %v", path, err)
			return nil
		}

		if info.IsDir() || !strings.HasSuffix(info.Name(), ".sql") {
			return nil
		}

		versions, fileName, hashKeys, scripts, tags := getVersionOracle(path)
		majorValue := strings.Split(filepath.Base(filepath.Dir(path)), "_")[0]

		for i, version := range versions {
			if tag == "" && tags[i] == "dev" {
				//logger.Printf("Skipping script %s due to tag: dev\n", fileName)
				continue
			}

			if tag != "" && tags[i] != tag {
				//logger.Printf("Skipping script %s due to tag mismatch: expected %s, found %s\n", fileName, tag, tags[i])
				continue
			}

			hk := hashKeys[i]
			script := scripts[i]
			status := ""

			if containsOracle(hashCodes, hk) && !strings.HasPrefix(fileName, "c") {
				status = "skipped"
				skippedFiles = append(skippedFiles, fileName)
				logger.Printf("Execution skipped due to matching hash code: %s, change: %s\n", filepath.Base(fileName), version)
			} else {
				sqlScript := removeCommentsOracle(script)
				statements := strings.Split(sqlScript, ";")
				success := true

				for _, statement := range statements {
					if strings.TrimSpace(statement) != "" {
						_, err := db.Exec(statement)
						if err != nil {
							logger.Printf("Error executing script %s: %v", fileName, err)
							success = false
							break
						}
					}
				}

				if success {
					status = "success"
					logger.Printf("Execution success for script: %s, change: %s\n", filepath.Base(fileName), version)
				} else {
					status = "failed"
					logger.Printf("Execution failed for script: %s, change: %s\n", filepath.Base(fileName), version)
				}
			}

			minorValue := strings.Split(strings.Split(fileName, "_")[0], "_")[0]

			scriptIDCounter++

			if (tag == "" && tags[i] != "dev") || (tag != "" && tags[i] == tag) {
				existingRecordID := checkExistingRecordOracle(db, majorValue, minorValue, version)
				executionTime := time.Now()

				if status != "failed" {
					if existingRecordID != -1 {
						_, err = db.Exec(
							"UPDATE tbl_version SET Status=:1, HashCode=:2, ExecutionTime=:3 WHERE Id=:4",
							status, hk, executionTime, existingRecordID)
					} else {
						_, err = db.Exec(
							"INSERT INTO tbl_version (Major, Minor, \"Change\", Status, HashCode, ExecutionTime) VALUES (:1, :2, :3, :4, :5, :6)",
							majorValue, minorValue, version, status, hk, executionTime)
					}

					if err != nil {
						logger.Fatalf("Error updating/inserting record: %v", err)
					}
				}

				tableWriter.AppendRow([]interface{}{scriptIDCounter, majorValue, minorValue, version, status, hk, executionTime})
				hashCodes = append(hashCodes, hk)
			}
		}
		return nil
	})

	if err != nil {
		logger.Fatalf("Error iterating over files: %v", err)
	}

	tableWriter.Render()

	return db
}

func retrieveHashCodesOracle(db *sql.DB) []string {
	var hashCodes []string
	rows, err := db.Query("SELECT HashCode FROM tbl_version")
	if err != nil {
		log.Fatalf("Error retrieving hash codes: %v", err)
	}
	defer rows.Close()

	for rows.Next() {
		var hashCode string
		if err := rows.Scan(&hashCode); err != nil {
			log.Fatalf("Error scanning hash code: %v", err)
		}
		hashCodes = append(hashCodes, hashCode)
	}

	return hashCodes
}

func removeCommentsOracle(sqlScript string) string {
	lines := strings.Split(sqlScript, "\n")
	var cleanedLines []string
	for _, line := range lines {
		if !strings.HasPrefix(line, "--") {
			cleanedLines = append(cleanedLines, line)
		}
	}
	return strings.Join(cleanedLines, "\n")
}

func getVersionOracle(filePath string) ([]string, string, []string, []string, []string) {
	content, err := ioutil.ReadFile(filePath)
	if err != nil {
		log.Fatalf("Error reading file %s: %v", filePath, err)
	}

	lines := strings.Split(string(content), "\n")
	var versions []string
	var hashKeys []string
	var scripts []string
	var tags []string
	var script string

	for _, line := range lines {
		if strings.HasPrefix(line, "--start version:") {
			parts := strings.SplitN(strings.TrimSpace(strings.TrimPrefix(line, "--start version:")), ";tag=", 2)
			version := parts[0]
			tag := ""
			if len(parts) == 2 {
				tag = parts[1]
			}
			versions = append(versions, version)
			tags = append(tags, tag)
		} else if strings.HasPrefix(line, "--end version:") {
			hashKey := fmt.Sprintf("%x", md5.Sum([]byte(script)))
			hashKeys = append(hashKeys, hashKey)
			scripts = append(scripts, script)
			script = ""
		} else {
			script += line + "\n"
		}
	}

	fileName := filepath.Base(filePath)
	return versions, fileName, hashKeys, scripts, tags
}

func containsOracle(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

func checkExistingRecordOracle(db *sql.DB, majorValue, minorValue, version string) int {
	var id int
	err := db.QueryRow("SELECT Id FROM tbl_version WHERE Major=:1 AND Minor=:2 AND \"Change\"=:3", majorValue, minorValue, version).Scan(&id)
	if err != nil {
		return -1
	}
	return id
}

func oracledelete(username, password, host, port, service, walletLocation string, logger *log.Logger) *sql.DB {
	connectionString := "oracle://" + username + ":" + password + "@" + host + ":" + port + "/" + service
	if walletLocation != "" {
		connectionString += "?TRACE FILE=trace.log&SSL=enable&SSL Verify=false&WALLET=" + url.QueryEscape(walletLocation)
	}
	var err error
	db, err = sql.Open("oracle", connectionString)
	if err != nil {
		logger.Printf("Error opening database connection: %v", err)
		return nil
	}

	err = db.Ping()
	if err != nil {
		logger.Printf("Error pinging database: %v", err)

		return nil
	}
	tableName := "tbl_Version"

	// Drop the specified table
	dropQuery := fmt.Sprintf("DROP TABLE %s", tableName)
	_, err = db.Exec(dropQuery)
	if err != nil {
		logger.Fatal("Error dropping table ", tableName, ": ", err)
	}

	logger.Println("Dropped table: ", tableName)
	return db
}
func oracledelete_all(username, password, host, port, service, walletLocation string, logger *log.Logger) *sql.DB {
	connectionString := "oracle://" + username + ":" + password + "@" + host + ":" + port + "/" + service
	if walletLocation != "" {
		connectionString += "?TRACE FILE=trace.log&SSL=enable&SSL Verify=false&WALLET=" + url.QueryEscape(walletLocation)
	}

	db, err := sql.Open("oracle", connectionString)
	if err != nil {
		logger.Printf("Error opening database connection: %v", err)
		return nil
	}

	err = db.Ping()
	if err != nil {
		logger.Printf("Error pinging database: %v", err)
		return nil
	}

	query := `
		SELECT table_name
		FROM user_tables
	`

	rows, err := db.Query(query)
	if err != nil {
		logger.Fatalf("Error fetching table names: %v", err)
		return nil
	}
	defer rows.Close()

	for rows.Next() {
		var tableName string
		if err := rows.Scan(&tableName); err != nil {
			logger.Printf("Error scanning table name: %v", err)
			continue
		}

		dropQuery := fmt.Sprintf("DROP TABLE %s CASCADE CONSTRAINTS", tableName)
		_, err := db.Exec(dropQuery)
		if err != nil {
			logger.Printf("Error dropping table %s: %v", tableName, err)
			continue
		}
		logger.Printf("Dropped table: %s", tableName)
	}

	if err := rows.Err(); err != nil {
		logger.Fatalf("Error iterating table rows: %v", err)
	}

	return db
}
func oracleCheckScripts(username, password, host, port, service, walletLocation, folderPath string, logger *log.Logger) {
	connectionString := "oracle://" + username + ":" + password + "@" + host + ":" + port + "/" + service
	if walletLocation != "" {
		connectionString += "?TRACE FILE=trace.log&SSL=enable&SSL Verify=false&WALLET=" + url.QueryEscape(walletLocation)
	}
	var err error
	db, err = sql.Open("oracle", connectionString)
	if err != nil {
		logger.Printf("Error opening database connection: %v", err)
		return
	}

	err = db.Ping()
	if err != nil {
		logger.Printf("Error pinging database: %v", err)
		return
	}

	// Retrieve executed scripts with their version tags from the database
	executedScripts := oracleGetExecutedScripts(db)

	// Parse scripts from the specified folder and subfolders with their version tags
	folderScripts := make(map[string][]string)
	err = filepath.Walk(folderPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			logger.Printf("Error accessing path %q: %v\n", path, err)
			return err
		}
		if !info.IsDir() && strings.HasSuffix(info.Name(), ".sql") {
			versions, fileName := oracleGetVersion(path)
			folderScripts[fileName] = versions
		}
		return nil
	})
	if err != nil {
		logger.Fatalf("Error walking through folder: %v", err)
	}

	// Compare executed scripts and folder scripts
	missingScripts := oracleFindMissingScripts(executedScripts, folderScripts)

	// Print missing scripts
	if len(missingScripts) > 0 {
		logger.Println("Versions in folder that have not been executed in the database:")
		for script, versions := range missingScripts {
			for _, version := range versions {
				logger.Printf("%s (version: %s)\n", script, version)
			}
		}
	} else {
		logger.Println("All scripts in folder have been executed in the database.")
	}
}

func oracleGetVersion(filePath string) ([]string, string) {
	content, err := ioutil.ReadFile(filePath)
	if err != nil {
		log.Fatalf("Error reading file %s: %v", filePath, err)
	}

	lines := strings.Split(string(content), "\n")
	var versions []string
	var script string

	for _, line := range lines {
		if strings.HasPrefix(line, "--start version:") {
			version := strings.TrimSpace(strings.TrimPrefix(line, "--start version:"))
			versions = append(versions, version)
		} else if strings.HasPrefix(line, "--end version:") {
			script = ""
		} else {
			script += line + "\n"
		}
	}

	fileName := filepath.Base(filePath)
	return versions, fileName
}

func oracleGetExecutedScripts(db *sql.DB) map[string]string {
	executedScripts := make(map[string]string)
	rows, err := db.Query("SELECT \"Change\" FROM tbl_version")
	if err != nil {
		log.Fatalf("Error retrieving executed scripts: %v", err)
	}
	defer rows.Close()

	for rows.Next() {
		var change string
		if err := rows.Scan(&change); err != nil {
			log.Fatalf("Error scanning \"Change\" column: %v", err)
		}
		executedScripts[change] = change
	}

	return executedScripts
}

func oracleFindMissingScripts(executedScripts map[string]string, folderScripts map[string][]string) map[string][]string {
	missingScripts := make(map[string][]string)

	for fileName, versions := range folderScripts {
		missingVersions := []string{}
		for _, version := range versions {
			if _, exists := executedScripts[version]; !exists {
				missingVersions = append(missingVersions, version)
			}
		}
		if len(missingVersions) > 0 {
			missingScripts[fileName] = missingVersions
		}
	}

	return missingScripts
}

// Function to get table names from the database
func oracleGetTableNames(db *sql.DB) ([]string, error) {
	query := "SELECT TABLE_NAME FROM USER_TABLES"
	rows, err := db.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var tableNames []string
	for rows.Next() {
		var tableName string
		if err := rows.Scan(&tableName); err != nil {
			return nil, err
		}
		tableNames = append(tableNames, tableName)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return tableNames, nil
}

// Function to generate SQL script for creating a table
func oracleGenerateScriptForTable(db *sql.DB, tableName string) (string, error) {
	query := fmt.Sprintf("SELECT COLUMN_NAME, DATA_TYPE, DATA_LENGTH FROM USER_TAB_COLUMNS WHERE TABLE_NAME = '%s'", tableName)
	rows, err := db.Query(query)
	if err != nil {
		return "", err
	}
	defer rows.Close()

	script := fmt.Sprintf("CREATE TABLE %s (\n", tableName)
	for rows.Next() {
		var columnName, dataType string
		var dataLength sql.NullInt64
		if err := rows.Scan(&columnName, &dataType, &dataLength); err != nil {
			return "", err
		}

		script += fmt.Sprintf("    %s %s", columnName, dataType)
		if dataType == "VARCHAR2" && dataLength.Valid {
			script += fmt.Sprintf("(%d)", dataLength.Int64)
		}
		script += ",\n"
	}
	if err := rows.Err(); err != nil {
		return "", err
	}
	script = script[:len(script)-2] + "\n);\n\n" // Remove the last comma and add closing bracket
	return script, nil
}

// Function to handle database connection and generate script
func oracleGenerateMigrationScript(host, port, database, username, password, folderPath, walletLocation, service, prestatefile string, logger *log.Logger) {
	connectionString := "oracle://" + username + ":" + password + "@" + host + ":" + port + "/" + service
	if walletLocation != "" {
		connectionString += "?TRACE FILE=trace.log&SSL=enable&SSL Verify=false&WALLET=" + url.QueryEscape(walletLocation)
	}

	db, err := sql.Open("oracle", connectionString)
	if err != nil {
		logger.Printf("Error opening database connection: %v", err)
		return
	}
	defer db.Close()

	err = db.Ping()
	if err != nil {
		logger.Printf("Error pinging database: %v", err)
		return
	}

	tableNames, err := oracleGetTableNames(db)
	if err != nil {
		logger.Println("Error getting table names:", err)
		return
	}

	var combinedScript string
	for _, tableName := range tableNames {
		script, err := oracleGenerateScriptForTable(db, tableName)
		if err != nil {
			logger.Println("Error generating script for table:", err)
			return
		}
		combinedScript += script
	}

	combinedSQLFilePath := filepath.Join(folderPath, prestatefile)
	file, err := os.Create(combinedSQLFilePath)
	if err != nil {
		logger.Println("Error creating file:", err)
		return
	}
	defer file.Close()

	_, err = file.WriteString(combinedScript)
	if err != nil {
		logger.Println("Error writing to file:", err)
		return
	}

	logger.Println("Script has been generated and saved to the specified file.")
}

// processFiles handles the core logic of reading the files, finding differences, and saving the output.
func oracle_processFiles(folderPath, prescript, postscript, difference string) error {
	// Construct file paths
	file1Path := filepath.Join(folderPath, prescript)
	file2Path := filepath.Join(folderPath, postscript)
	outputPath := filepath.Join(folderPath, difference)

	// Read the SQL files
	file1Content, err := ioutil.ReadFile(file1Path)
	if err != nil {
		return fmt.Errorf("error reading file1: %w", err)
	}

	file2Content, err := ioutil.ReadFile(file2Path)
	if err != nil {
		return fmt.Errorf("error reading file2: %w", err)
	}

	// Split the contents into individual statements
	statementsFile1 := oracle_splitSQLStatements(string(file1Content))
	statementsFile2 := oracle_splitSQLStatements(string(file2Content))

	// Find differences
	differences := oracle_findDifferences(statementsFile1, statementsFile2)
	fmt.Println("Differences have been saved to", difference)
	// Save the differences to a new SQL file
	return oracle_saveDifferencesToFile(outputPath, differences)
}

// splitSQLStatements splits the SQL script into individual statements.
func oracle_splitSQLStatements(content string) []string {
	statements := strings.Split(content, ";")
	var trimmedStatements []string
	for _, stmt := range statements {
		trimmedStmt := strings.TrimSpace(stmt)
		if trimmedStmt != "" {
			trimmedStatements = append(trimmedStatements, trimmedStmt+";")
		}
	}
	return trimmedStatements
}

// findDifferences returns the statements that are in file2 but not in file1.
func oracle_findDifferences(file1Statements, file2Statements []string) []string {
	file1Set := make(map[string]struct{})
	for _, stmt := range file1Statements {
		file1Set[stmt] = struct{}{}
	}

	var differences []string
	for _, stmt := range file2Statements {
		if _, found := file1Set[stmt]; !found {
			differences = append(differences, stmt)
		}
	}
	return differences
}

// saveDifferencesToFile saves the differences to a file.
func oracle_saveDifferencesToFile(filename string, differences []string) error {
	content := strings.Join(differences, "\n\n")
	return ioutil.WriteFile(filename, []byte(content), 0644)
}
